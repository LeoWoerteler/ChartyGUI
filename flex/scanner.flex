package de.woerteler.grammar;

import java_cup.runtime.Symbol;

/*
 * WARNING: This file is auto generated! Do NOT edit this file!
 * Edit flex/subsasl.flex instead.
 */

@SuppressWarnings("all")
%%
   
/* -----------------Options and Declarations Section----------------- */
   
/* 
   The name of the class JFlex will create will be Lexer.
   Will write the code to the file Lexer.java. 
*/

%public
%final
%class Lexer

/*
  The current line number can be accessed with the variable yyline
  and the current column number with the variable yycolumn.
*/
%line
%column

%unicode
    
/* 
   Will switch to a CUP compatibility mode to interface with a CUP
   generated parser.
*/
%cup

%eofval{
    return symbol(Terminal.EOF);
%eofval}
   
/*
  Declarations
   
  Code between %{ and %}, both of which must be at the beginning of a
  line, will be copied letter to letter into the lexer class source.
  Here you declare member variables and functions that are used inside
  scanner actions.  
*/
%{

  /*
   * To create a new java_cup.runtime.Symbol with information about the
   * current token, the token will have no value in this case.
   */
  private Symbol symbol(final int type) {
    return new Symbol(type, yyline, yycolumn);
  }

  /*
   * Also creates a new java_cup.runtime.Symbol with information about the
   * current token, but this object has a value.
   */
  private Symbol symbol(final int type, final Object value) {
      return new Symbol(type, yyline, yycolumn, value);
  }

  /**
   * Decodes a quoted string with escaped characters.
   * 
   * @param lit literal string
   * @return decoded string
   */
  private String decode(final String lit) {
    final StringBuilder sb = new StringBuilder();
    int cp;
    for(int i = 1; i < lit.length() - 1; i += Character.charCount(cp)) {
      cp = lit.codePointAt(i);
      if(cp == '\\') {
        cp = lit.codePointAt(++i);
      }
      sb.append(Character.toChars(cp));
    }
    return sb.toString();
  }

%}
   

/*
  Macro Declarations
  
  These declarations are regular expressions that will be used latter
  in the Lexical Rules Section.  
*/
   
/* A line terminator is a \r (carriage return), \n (line feed), or \r\n. */
LineTerminator = \r|\r?\n
   
/* White space is a line terminator, space, tab, or line feed. */
WhiteSpace     = {LineTerminator} | [ \t\f]
Comment        = \/\/[^\r\n]*

/* literals */
name            = [A-Z][a-zA-Z0-9']*
term            = \"([^\"\\\r\n]|\\\"|\\\\)*\"
errstr          = \"[^\"]+\"|\'[^\']+\'

%%
/* ------------------------Lexical Rules Section---------------------- */
   
/*
   This section contains regular expressions and actions, i.e. Java
   code, that will be executed when the scanner matches the associated
   regular expression. */
   
   /* YYINITIAL is the state at which the lexer begins scanning.  So
   these regular expressions will only be matched if the scanner is in
   the start state YYINITIAL. */
   
<YYINITIAL> {
    {WhiteSpace}    { break; }
    {Comment}       { break; }

    /* operators */
    "+"             { return symbol(Terminal.PLUS); }
    "*"             { return symbol(Terminal.STAR); }
    "?"             { return symbol(Terminal.Q_MARK); }
    "("             { return symbol(Terminal.PAR_L); }
    ")"             { return symbol(Terminal.PAR_R); }
    "->"            { return symbol(Terminal.TO); }
    "|"             { return symbol(Terminal.OR); }
    "."             { return symbol(Terminal.DOT); }

    /* literals */
    {name}          { return symbol(Terminal.NON_TERMINAL, yytext()); } 
    {term}          { return symbol(Terminal.TERMINAL, decode(yytext())); }
    {errstr}        { return symbol(Terminal.error, yytext()); }
    
}


/* No token was found for the input so through an error.  Print out an
   Illegal character message with the illegal character that was found. */
[^]                 { return symbol(Terminal.error, yytext()); }
